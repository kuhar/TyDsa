.symbol_type reg
.symbol_type heap
.symbol_type type
.symbol_type list
.number_type num

// -- inputs --
.decl alloca(t:type, r:reg, h:heap)
.decl malloc(t:type, r:reg, n:num, h:heap)
.decl load(res_ty:type, r:reg, from_ty:type, from:reg)
.decl store(val_ty:type, val:reg, dest_ty:type, dest:reg)
.decl bitcast(to_ty:type, r:reg, val_ty:type, val:reg)
.decl gep(t:type, r:reg, src_ty:type, src:reg, idx:num)
.decl phi(t:type, r:reg, src_a:reg, src_b:reg)

// True iff ptr_ty is src_ty*
.decl ptrOf(src_ty:type, ptr_ty:type)
// True iff elem_ty* is ptr_ty
.decl elemOf(ptr_ty:type, elem_ty:type)
elemOf(PtrT, T) :- ptrOf(T, PtrT).
.decl isPtrTy(t:type)
isPtrTy(T) :- elemOf(T, _).

.decl sizeOf(ty:type, sz:num)
sizeOf(PtrT, 8) :- isPtrTy(PtrT).

.decl class(name:type, num_fields:num)
.decl field(class:type, ty:type, index:num)

.decl has_type(ty_list:list, ty:type)
has_type(L, T) :- contains(type, list).

.decl append_type(in_list:list, ty:type, out_list:list)


#include "_current_test.dl"



// -- debug info and helpers --

// [Debug] Track all used registers.
.decl register(r:reg, t:type)
register(R, T) :- alloca(T, R, _).
register(R, T) :- malloc(T, R, _, _).
register(R, T) :- load(T, R, _, _).
register(ValR, ValT),
register(DestR, DestT) :- store(ValT, ValR, DestT, DestR).
register(R, T) :- bitcast(T, R, _,  _).
register(R, T) :- gep(T, R, _, _, _).
register(R, T) :- phi(T, R, _, _).
//.output register()

// [Debug] track all heap objects.
.decl heap_obj(h:heap, size:num)
heap_obj(H, N) :- alloca(PtrT, _, H), elemOf(PtrT, T), sizeOf(T, N).
heap_obj(H, N) :- malloc(_, _, N, H).
.output heap_obj()

// [Debug] Display all known types grouped by element type.
.decl ty_hierarchy(t0:type, t1:type, t2:type)
ty_hierarchy(T0, T1, T2) :- ptrOf(T0, T1), ptrOf(T1, T2), elemOf(T2, T1), elemOf(T1, T0).
//.output ty_hierarchy()

// -- analysis --

.decl sizeOfClass_n(name:type, n:num, acc_sz:num)
sizeOfClass_n(C, 0, Sz) :- class(C, _), field(C, FldTy, 0), sizeOf(FldTy, Sz).
sizeOfClass_n(C, K, AccSz + Sz) :- sizeOfClass_n(C, K - 1, AccSz),
                                   field(C, FldTy, K), sizeOf(FldTy, Sz).
sizeOf(C, Sz) :- class(C, N), sizeOfClass_n(C, N - 1, Sz).  

.decl typeAtOffset(class_ty:type, ty:type, offset:num)
typeAtOffset(T, T, 0) :- sizeOf(T, _).  
typeAtOffset(C, T, N - SzT) :- sizeOfClass_n(C, K, N),
                               field(C, T, K), sizeOf(T, SzT).
typeAtOffset(C, InnT, N + M) :- typeAtOffset(C, T, N),
                                typeAtOffset(T, InnT, M).

.decl isPrimitive(T:type)
isPrimitive(T) :- sizeOf(T, _), !class(T, _).

.decl innerPrimitiveTy(ty:type, inner_ty:type)
innerPrimitiveTy(T, InnT) :- typeAtOffset(T, InnT, _), 
                             isPrimitive(InnT).

.decl heapTypes(h:heap, tys:type_list)
.output heapTypes()

.decl heapField(h:heap, fld_ty:type)
.decl allocFn(r:reg, h:heap)
allocFn(R, H) :- alloca(_T, R, H).
allocFn(R, H) :- malloc(_T, R, _N, H).

.decl memAccess(ptrT:type, r:reg)
memAccess(T, R) :- load(T, _, _PtrT, R).
memAccess(T, ValR) :- store(ValT, ValR, _, _), elemOf(ValT, T).
memAccess(ValT, SrcR) :- store(ValT, _, _SrcT, SrcR).

// Register points to a field of a given type in a given heap.
.decl RegPtsTo(r:reg, h:heap, t:type)

// Register comes from a pointer register of some type, ignoring bitcasts.
.decl StripPtrCasts(r:reg, source:reg, t:type)

.decl RegOrigin(r:reg, origin:reg)

// A field of a given type points to another field in a given heap,
// of a given type. source field type is type*. 
.decl FldPtsTo(h1:heap, t1:type, h2:heap, t2:type)

.decl HeapPtsTo(h1:heap, h2:heap)
HeapPtsTo(H1, H2) :- FldPtsTo(H1, _, H2, _).

// Given heap is type-collapsed.
.decl tCollapsed(h:heap)

StripPtrCasts(R, R, T) :- alloca(T, R, _).
StripPtrCasts(R, R, T) :- malloc(T, R, _, _).
StripPtrCasts(R, R, T) :- load(T, R, _, _), isPtrTy(T).
StripPtrCasts(R, R, T) :- gep(T, R, _, _, _), isPtrTy(T).
StripPtrCasts(R, R, T) :- phi(T, R, _, _), isPtrTy(T).
StripPtrCasts(R, Source, T) :- StripPtrCasts(R1, Source, T), 
                               bitcast(T1, R, T2, R1),
                               isPtrTy(T1), isPtrTy(T2).


RegOrigin(R, R) :- alloca(_, R, _).
RegOrigin(R, R) :- malloc(_, R, _, _).
RegOrigin(R, R) :- load(T, R, _, _), isPtrTy(T).
RegOrigin(R, R) :- gep(_, R, _, _SrcR, N), N != 0.
RegOrigin(R, SrcR) :- gep(_, R, _, SrcR, 0).
RegOrigin(R, SrcR1),
RegOrigin(R, SrcR2) :- phi(T, R, R1, R2), isPtrTy(T),
                       RegOrigin(R1, SrcR1),
                       RegOrigin(R2, SrcR2).
RegOrigin(R, Src) :- bitcast(_, R, _, R2), RegOrigin(R2, Src).

.decl NewRPT(r:reg, h:heap, t:type)
heapField(H, T) :- NewRPT(_, H, T).

NewRPT(R, H, T) :- NewRPT(SrcR, H, T), RegOrigin(R, SrcR).
NewRPT(R, H, T) :- memAccess(T, AccR), RegOrigin(AccR, R),
                   allocFn(R, H).
NewRPT(FldR, H, FldTy) :- gep(FldPtrT, FldR, SrcTy, SrcR, N), N != 0,
                          elemOf(FldPtrT, FldTy),  
                          RegOrigin(SrcR, R), allocFn(R, H).
                   
NewRPT(AccR, H, T) :- memAccess(T, AccR), RegOrigin(AccR, R),
                      NewRPT(R, H, _).

RegPtsTo(R, H, T) :- StripPtrCasts(R, Source, _), RegPtsTo(Source, H, T).
RegPtsTo(R, H, T) :- alloca(T, R, H).
RegPtsTo(R, H, "i8") :- malloc(_, R, _, H).

RegPtsTo(R, H, FT) :- RegPtsTo(R2, H, _),
                      gep(PtrT, R, _, R2, _), elemOf(PtrT, FT).

// One way - Andersen, two way - Steensgaard.
RegPtsTo(R, H1, T1), RegPtsTo(R, H2, T2) :- 
        RegPtsTo(R1, H1, T1), RegPtsTo(R2, H2, T2), phi(T, R, R1, R2).


RegPtsTo(R, H2, T) :- load(T, R, _, Source),
                      RegPtsTo(Source, H1, _),
                      FldPtsTo(H1, _, H2, _).
 

FldPtsTo(H1, DstPtrTy, H2, ValPtrTy) :- store(ValPtrTy, Val, DstPtrTy, Dst),
                                        RegPtsTo(Val, H2, _SrcTy),
                                        RegPtsTo(Dst, H1, _DstTy).


// If H1 is collapsed, a pointer from any outgoing pointer goes to all destination fields.
//FldPtsTo(H1, T1, H2, T2) :- tCollapsed(H1), FldPtsTo(H1, _, H2, T2), 
//                                            FldPtsTo(H1, T1, H2, _).

// If H2 is collapsed, a pointer to H2 is a pointer to any (known) field of H2.
//FldPtsTo(H1, T1, H2, T2) :- tCollapsed(H2), FldPtsTo(H1, T1, H2, _),
//                                            FldPtsTo(_, _, H2, T2).

//RegPtsTo(R, H, T2) :- tCollapsed(H), RegPtsTo(R, H, _T1), RegPtsTo(_R2, H, T2).

//tCollapsed(H) :- FldPtsTo(H1, PtrT1, H, T1), FldPtsTo(H1, PtrT1, H, T2), T1 != T2.
// tCollapsed(H) :- RegPtsTo(_, H, T1), RegPtsTo(_, H, T2), T1 != T2.
//.output tCollapsed()

// [Debug] Dump tables.
//.output sizeOf()
//.output field()
//.output sizeOfClass_n()
//.output typeAtOffset()
.output heapField()
.output RegOrigin() 
.output StripPtrCasts()
//.output RegPtsTo()
.output NewRPT()
.output memAccess()
.output FldPtsTo()
.output HeapPtsTo()