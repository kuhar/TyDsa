// Andersen, language w/ types and no offsets

// TODO: what does DSA say about overlapping writers/reads of fields?
// Assumption: in concrete semantics, a write that overlaps many fields is not allowed
// Alternative assumption: overlapping write doesn't create new legal pointers

// Restriction: load of a pointer must read from a properly typed memory

.decl alloca(t:type, r:reg, h:heap)
.decl load(res_ty:type, r:reg, from_ty:type, from:reg)

.decl store(val_ty:type, val:reg, dest_ty:type, dest:reg)
.decl assign(t:type, r:reg, src_a:reg)
.decl gep(t:type, r:reg, src_r:reg, f:field)

.decl RegPtsToFld(r:reg, h:heap, f:field)
.decl FldPtsToFld(h_src:heap, f_src:field, h_dst:heap, f_dst:field)


// RegPtrsObj(R, H) :- RegPtsToFld(R, H, _).

RegPtsToFld(R, H, T) :- alloca(_, R, H), isTy(T).

RegPtsToFld(R, H, T) :- gep(_, R, SrcR, _), RegPtsToObj(SrcR, H), isTy(T).
// ? RegPtsToFld(R, H, T) :- gep(T*, R, SrcR, _), RegPtsToObj(SrcR, H).

RegPtsToFld(R, H, T) :- assign(_, R, Src), RegPtsToFld(Src, H, T).

RegPtsToFld(SrcR, H2, T) :- load(T, R, SrcT, SrcR), RegPtsFld(SrcR, H, T),
                            FldPtsToFld(H, T, H2, T2), isPtrTy(T).


RegPtsToFld(R, H2, T) :- store(ValT, ValR, DstT, DstR), RegPtsFld(DstR, H, T),
                            FldPtsToFld(H, T, H2, T2), isPtrTy(T).


~RegPtsToFld(R, H2, T3) :- load(T, R, SrcT, SrcR), RegPtsFld(SrcR, H, T),
                           FldPtsToFld(H, T, H2, T2), isPtrTy(T), T3 != T.


FldPtsToFld(H2, T2, H1, T1), :- store(PtrTy, Ptr, DstTy, DstR), isPtrTy(PtrTy),
                               RegPtsToFld(Ptr, H1, T1), RegPtsToFld(DstR, H2, T2).

RegPtsToFld(DstR, H2, T) :- store(ValT, ValR, DstT, DstR), RegPtsFld(DstR, H, T),
                            FldPtsToFld(H, T, H2, T2), isPtrTy(T).



RegPtsToFld(SrcR, H, SrcT) :- load(T, R, SrcT, SrcR), RegPtsObj(SrcR, H).
RegPtsToFld(DstR, H, DstTy) :- store(Val, ValT, DstTy, DstR), RegPtsObj(DstR, H).
